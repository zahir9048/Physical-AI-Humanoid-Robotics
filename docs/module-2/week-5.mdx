---
sidebar_label: 'Week 5: Advanced ROS 2 Concepts and Tools'
---

# Module 2: ROS 2 Fundamentals

## Week 5: Advanced ROS 2 Concepts and Tools

### Learning Objectives:
- Explore advanced ROS 2 communication patterns like actions and parameters.
- Utilize ROS 2 debugging and visualization tools.
- Understand the concepts of security and quality of service (QoS) in ROS 2.

### Content:
- ROS 2 actions for long-running tasks.
- Dynamic parameters and configuration.
- Rviz2 for 3D visualization.
- rqt_graph and other rqt tools for introspection.
- Introduction to ROS 2 security (SROS 2) and QoS policies.

### Detailed Code Examples:

#### Creating an Action Server
```python
import time
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from example_interfaces.action import Fibonacci

class FibonacciActionServer(Node):

    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback)

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()

            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])

            goal_handle.publish_feedback(feedback_msg)
            time.sleep(1)

        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        self.get_logger().info('Returning result: {0}'.format(result.sequence))

        return result

def main(args=None):
    rclpy.init(args=args)
    fibonacci_action_server = FibonacciActionServer()
    rclpy.spin(fibonacci_action_server)
    fibonacci_action_server.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Using Dynamic Parameters
```python
import rclpy
from rclpy.node import Node
from rcl_interfaces.msg import ParameterType
from rcl_interfaces.msg import SetParametersResult

class ParameterNode(Node):

    def __init__(self):
        super().__init__('parameter_node')

        # Declare parameters with default values
        self.declare_parameter('robot_name', 'turtlebot')
        self.declare_parameter('max_velocity', 1.0)
        self.declare_parameter('safety_distance', 0.5)

        # Register callback for parameter changes
        self.add_on_set_parameters_callback(self.parameter_callback)

        # Get parameter values
        self.robot_name = self.get_parameter('robot_name').value
        self.max_velocity = self.get_parameter('max_velocity').value
        self.safety_distance = self.get_parameter('safety_distance').value

        self.get_logger().info(f'Robot: {self.robot_name}, Max Vel: {self.max_velocity}, Safety Dist: {self.safety_distance}')

    def parameter_callback(self, params):
        result = SetParametersResult()
        result.successful = True

        for param in params:
            if param.name == 'max_velocity' and param.type == ParameterType.PARAMETER_DOUBLE:
                if param.value < 0.0 or param.value > 5.0:
                    result.successful = False
                    result.reason = 'Max velocity must be between 0.0 and 5.0'
                    return result

        return result

def main(args=None):
    rclpy.init(args=args)
    node = ParameterNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Practical Exercises:
1. **Exercise 1:** Create an action server that simulates a robot moving to a goal position with feedback on progress.
2. **Exercise 2:** Implement a node that uses dynamic parameters to adjust robot speed and turning radius during operation.
3. **Exercise 3:** Use rqt_graph to visualize the communication between your nodes from previous exercises.
4. **Exercise 4:** Create a QoS profile with reliable delivery and keep-all history, then test it with your publisher/subscriber nodes.
